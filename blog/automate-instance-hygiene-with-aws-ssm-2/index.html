<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><script async defer data-domain=jdheyburn.co.uk src=https://stats.jdheyburn.co.uk/js/index.js></script><meta name=author content="Joseph D. Heyburn"><meta name=description content="Ramblings of a tech guy"><meta name=keywords content="blog,developer,devops,cloud"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jdheyburn.co.uk/blog/automate-instance-hygiene-with-aws-ssm-2/card.png"><meta name=twitter:title content="Automate Instance Hygiene with AWS SSM: Automation Documents"><meta name=twitter:description content="Introducing checks in our automation workflow to reduce the spread of broken patches to our estate"><meta property="og:title" content="Automate Instance Hygiene with AWS SSM: Automation Documents"><meta property="og:description" content="Introducing checks in our automation workflow to reduce the spread of broken patches to our estate"><meta property="og:type" content="article"><meta property="og:url" content="https://jdheyburn.co.uk/blog/automate-instance-hygiene-with-aws-ssm-2/"><meta property="og:image" content="https://jdheyburn.co.uk/blog/automate-instance-hygiene-with-aws-ssm-2/card.png"><meta property="article:published_time" content="2020-12-04T00:00:00+00:00"><meta property="article:modified_time" content="2020-12-04T00:00:00+00:00"><base href=https://jdheyburn.co.uk/blog/automate-instance-hygiene-with-aws-ssm-2/><title>Automate Instance Hygiene with AWS SSM: Automation Documents · JDHeyburn</title><link rel=canonical href=https://jdheyburn.co.uk/blog/automate-instance-hygiene-with-aws-ssm-2/><link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700&display=swap" rel=stylesheet><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.13.0/css/all.css integrity=sha384-Bfad6CLCknfcloXFOyFnlgtENryhrpZCe29RTifKEixXQZ38WheV+i/6YWSzkz3V crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin=anonymous><link rel=stylesheet href=https://jdheyburn.co.uk/css/coder.min.a4f332213a21ce8eb521670c614470c58923aaaf385e2a73982c31dd7642decb.css integrity="sha256-pPMyITohzo61IWcMYURwxYkjqq84XipzmCwx3XZC3ss=" crossorigin=anonymous media=screen><link rel=stylesheet href=https://jdheyburn.co.uk/css/coder-dark.min.83a2010dac9f59f943b3004cd6c4f230507ad036da635d3621401d42ec4e2835.css integrity="sha256-g6IBDayfWflDswBM1sTyMFB60DbaY102IUAdQuxOKDU=" crossorigin=anonymous media=screen><link rel=stylesheet href=https://jdheyburn.co.uk/css/custom.css><link rel=icon type=image/png href=https://jdheyburn.co.uk/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=https://jdheyburn.co.uk/images/favicon-16x16.png sizes=16x16><meta name=generator content="Hugo 0.82.1"></head><body class=colorscheme-dark><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://jdheyburn.co.uk/>JDHeyburn</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fas fa-bars"></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=https://jdheyburn.co.uk/about/>About</a></li><li class=navigation-item><a class=navigation-link href=https://jdheyburn.co.uk/blog/>Blog</a></li><li class=navigation-item><a class=navigation-link href=https://jdheyburn.co.uk/projects/>Projects</a></li><li class=navigation-item><a class=navigation-link href=https://jdheyburn.co.uk/contact/>Contact</a></li></ul></section></nav><div class=content><section class="container post"><article><div><img class=featimage src=https://jdheyburn.co.uk/blog/automate-instance-hygiene-with-aws-ssm-2/cover.png alt="Featured image"></div><header><div class=post-title><h1 class=title>Automate Instance Hygiene with AWS SSM: Automation Documents</h1></div><div class=post-description><p>Introducing checks in our automation workflow to reduce the spread of broken patches to our estate</p></div><div class=post-meta><div class=date><span class=posted-on><i class="fas fa-calendar"></i>
<time datetime=2020-12-04T00:00:00Z>4 December 2020</time></span>
<span class=reading-time><i class="fas fa-clock"></i>
14-minute read</span></div><div class=tags><i class="fas fa-tag"></i>
<a href=https://jdheyburn.co.uk/tags/aws/>aws</a>
<span class=separator>•</span>
<a href=https://jdheyburn.co.uk/tags/ssm/>ssm</a>
<span class=separator>•</span>
<a href=https://jdheyburn.co.uk/tags/automation/>automation</a>
<span class=separator>•</span>
<a href=https://jdheyburn.co.uk/tags/terraform/>terraform</a>
<span class=separator>•</span>
<a href=https://jdheyburn.co.uk/tags/patching/>patching</a></div></div></header><div><aside><nav id=TableOfContents><ul><li><a href=#tldr>tl;dr</a></li><li><a href=#prerequisites>Prerequisites</a></li><li><a href=#automation-documents>Automation Documents</a><ul><li><a href=#introducing-proactive-healthchecks>Introducing proactive healthchecks</a></li></ul></li><li><a href=#combining-command-docs-into-automation>Combining command docs into automation</a><ul><li><a href=#terraform-automation-documents>Terraform automation documents</a></li><li><a href=#testing-automation-documents>Testing automation documents</a></li><li><a href=#failure-testing>Failure testing</a></li></ul></li><li><a href=#configuring-automation-tasks-for-maintenance-windows>Configuring automation tasks for maintenance windows</a><ul><li><a href=#maintenance-window-task>Maintenance window task</a></li><li><a href=#maintenance-window-target>Maintenance window target</a></li><li><a href=#additional-iam-policies>Additional IAM policies</a></li><li><a href=#testing-automation-documents-in-maintenance-windows>Testing automation documents in maintenance windows</a></li></ul></li><li><a href=#bonus-using-automation-to-dynamically-invoke-command-documents>Bonus: Using automation to dynamically invoke command documents</a><ul><li><a href=#terraforming-dynamic-command-documents>Terraforming dynamic command documents</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></aside><p>In <a href=https://jdheyburn.co.uk/blog/automate-instance-hygiene-with-aws-ssm-1/>part two</a> of this <a href=https://jdheyburn.co.uk/series/automate-instance-hygiene-with-aws-ssm/>series</a> we looked at how we can automate SSM command documents using SSM Maintenance Windows.</p><p>This part will now explore another type of SSM Document; Automation.</p><h2 id=tldr>tl;dr</h2><ul><li>Automation documents can allow us to combine command documents together</li><li>With this, we can utilise maintenance window error thresholds to stop further invocations</li><li>Dynamic invocation of command documents can also be achieved with automation documents</li></ul><h2 id=prerequisites>Prerequisites</h2><p>All the code for this post can be found on <a href=https://github.com/jdheyburn/terraform-examples/tree/main/aws-ssm-automation-2>GitHub</a>.</p><p>You&rsquo;ll notice that we have changed some things around in this post, so if you&rsquo;ve been using <code>terraform apply</code> in other posts to deploy to your AWS environment, you will notice some destructions.</p><p>Instead of having 1 Windows and 1 Linux EC2 instance, we&rsquo;re now using <a href=https://github.com/jdheyburn/terraform-examples/blob/main/aws-ssm-automation-2/ec2.tf>3 Linux EC2 instances</a> - to emulate an application running across multiple instances for redundancy. You don&rsquo;t actually need anything to be running on these instances, just have them visible in the <a href=https://console.aws.amazon.com/systems-manager/managed-instances>Managed Instances</a> console.</p><blockquote><p>Note that the EC2 instances are tagged with the key <code>App</code> and value <code>HelloWorld</code> - we&rsquo;ll be using this to specify our automation document targets.</p></blockquote><h2 id=automation-documents>Automation Documents</h2><p>Back in <a href=https://jdheyburn.co.uk/blog/automate-instance-hygiene-with-aws-ssm-0/>part one</a> I gave a brief intro to automation documents. To save the click:</p><blockquote><p>Automation document can call and orchestrate AWS API endpoints on your behalf, including executing Command documents on instances</p></blockquote><p>Essentially we can combine two command documents into one with an automation document. But why would we want to do this?</p><h3 id=introducing-proactive-healthchecks>Introducing proactive healthchecks</h3><p>Well in the last post, we set up a maintenance window with two tasks; one for invoking <strong>AWS-RunPatchBaseline</strong> and another for <strong>PerformHealthcheckS3</strong> (our healthcheck SSM Document) - both of these are <em>command documents</em>. Say if we had a policy that wanted to ensure that after <strong>AWS-RunPatchBaseline</strong> was invoked, we would <em>always</em> want the <strong>PerformHealthcheckS3</strong> invoked afterward&mldr; the Automation Document would help us get there.</p><p>Not only that, the way that our maintenance window is <a href=https://jdheyburn.co.uk/blog/automate-instance-hygiene-with-aws-ssm-1/#maintenance-window-tasks>currently structured</a> is it will invoke <strong>AWS-RunPatchBaseline</strong> across all instances in scope at the same time. Once they are all done then it will invoke <strong>PerformHealthcheckS3</strong> across all instances at the same time. This looks like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>Given we have 2 instances; i-111, i-222

T+0: Invoke AWS-RunPatchBaseline on i-111, i-222
T+1: AWS-RunPatchBaseline finishes: i-111, i-222
T+2: Invoke PerformHealthcheckS3 on i-111, i-222
T+3: PerformHealthcheckS3 finishes: i-111, i-222
</code></pre></div><p>Say if you wanted to limit the rate of patching across these instances so that only one instance at a time was patched, and any healthcheck failures aborted the rest of patching, then simply changing <code>max_concurrency</code> from <code>100%</code> to <code>1</code> for each maintenance window task <em>will not achieve this</em>.</p><p>Maintenance windows complete one task across all instances in scope before moving onto the next task. If we have Task 1 for Patching and Task 2 for Healthchecking (is that even a word?), then the maintenance window is going to patch <strong>all</strong> instances first before it performs healthchecks on the instances. There is no way to execute the tasks synchronously on one instance at a time.</p><p>This means that if a bad patch were to be installed in your estate, you could have this order of events:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>Given we have 2 instances; i-111, i-222

T+0: Invoke AWS-RunPatchBaseline on i-111
T+1: AWS-RunPatchBaseline finishes: i-111
T+2: Invoke AWS-RunPatchBaseline on i-222
T+3: AWS-RunPatchBaseline finishes: i-222
T+4: Invoke PerformHealthcheckS3 on i-111
T+5: PerformHealthcheckS3 FAILS: i-111
T+6: Invoke PerformHealthcheckS3 on i-222
T+7: PerformHealthcheckS3 FAILS: i-222
</code></pre></div><p>Now the healthcheck has failed for <code>i-222</code> as well because the bad patch landed on both instances, and production now has an outage.</p><h4 id=solution>Solution</h4><p>Thankfully, Automation Documents help us avoid that - by combining the two command documents (AWS-RunPatchBaseline and PerformHealthcheckS3), we can mark this new automation document as a <em>solo maintenance window task</em> and have it invoked one at a time on instances, and have it abort further invocations if any sub-documents failed within in:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>Given we have 2 instances; i-111, i-222

T+0: Invoke AWS-RunPatchBaseline on i-111
T+1: AWS-RunPatchBaseline finishes: i-111
T+2: Invoke PerformHealthcheckS3 on i-111
T+3: PerformHealthcheckS3 FAILS: i-111
T+4: Abort invoking AWS-RunPatchBaseline on i-222
T+5: Abort invoking PerformHealthcheckS3 on i-222
</code></pre></div><p>Notice how the failed healthcheck on the first instance caused the rest of task invocations to abort? Here is the order of events for a happy path.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>Given we have 2 instances; i-111, i-222

T+0: Invoke AWS-RunPatchBaseline on i-111
T+1: AWS-RunPatchBaseline finishes: i-111
T+2: Invoke PerformHealthcheckS3 on i-111
T+3: PerformHealthcheckS3 succeeds: i-111
T+4: Invoke AWS-RunPatchBaseline on i-222
T+5: AWS-RunPatchBaseline finishes: i-222
T+6: Invoke PerformHealthcheckS3 on i-222
T+7: PerformHealthcheckS3 succeeds: i-222
</code></pre></div><p>So we know that automation documents allow us to combine command documents together - this is done using the <code>aws:runCommand</code> action, though there are <a href=https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-actions.html>many more</a> actions available to you, some of which we&rsquo;ll explore later.</p><h2 id=combining-command-docs-into-automation>Combining command docs into automation</h2><p>We combine command documents as below in YAML; like command documents they can also be defined in JSON.</p><p>For the first time we are defining a parameter called <code>InstanceIds</code>, which takes in a list of instance IDs to then pass down to the command documents, as they will need to know what instances to invoke the commands on. The value assigned to this parameter is retrieved back with the notation <code>"{{ InstanceIds }}"</code>, which you can see being passed into the inputs of the sub-documents.</p><blockquote><p><code>InstanceIds</code> is a special parameter name that AWS recognises and so will provide an instance picker in the GUI of Execute Automation, as shown below.</p></blockquote><figure class=center><a href=instance-id-picker.png><img src=instance-id-picker.png alt="A screenshot of the execute automation page with the instance ID picker being used to select instances in scope"></a><figcaption><p>The instance picker can be helpful if you only want to target a subset of instances in your estate.</p></figcaption></figure><p>We&rsquo;re also following logging best practices by having the command output logged to S3.</p><p>Other than that, there&rsquo;s not really a whole lot of difference between this and a command document, so far!</p><blockquote><p>It&rsquo;s important to note the <code>schemaVersion</code> must be <code>0.3</code> for automation documents.</p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
<span style=color:#ff79c6>schemaVersion</span>: <span style=color:#f1fa8c>&#34;0.3&#34;</span>
<span style=color:#ff79c6>description</span>: Executes a patching event on the instance followed by a healthcheck
<span style=color:#ff79c6>parameters</span>:
  <span style=color:#ff79c6>InstanceIds</span>:
    <span style=color:#ff79c6>type</span>: StringList
    <span style=color:#ff79c6>description</span>: The instance to target
<span style=color:#ff79c6>mainSteps</span>:
  - <span style=color:#ff79c6>name</span>: InvokePatchEvent
    <span style=color:#ff79c6>action</span>: aws:runCommand
    <span style=color:#ff79c6>inputs</span>:
      <span style=color:#ff79c6>DocumentName</span>: AWS-RunPatchBaseline
      <span style=color:#ff79c6>InstanceIds</span>: <span style=color:#f1fa8c>&#34;{{ InstanceIds }}&#34;</span>
      <span style=color:#ff79c6>OutputS3BucketName</span>: jdheyburn-scripts
      <span style=color:#ff79c6>OutputS3KeyPrefix</span>: ssm_output/
      <span style=color:#ff79c6>Parameters</span>:
        <span style=color:#ff79c6>Operation</span>: Scan
  - <span style=color:#ff79c6>name</span>: ExecuteHealthcheck
    <span style=color:#ff79c6>action</span>: aws:runCommand
    <span style=color:#ff79c6>inputs</span>:
      <span style=color:#ff79c6>DocumentName</span>: PerformHealthcheckS3
      <span style=color:#ff79c6>InstanceIds</span>: <span style=color:#f1fa8c>&#34;{{ InstanceIds }}&#34;</span>
      <span style=color:#ff79c6>OutputS3BucketName</span>: jdheyburn-scripts
      <span style=color:#ff79c6>OutputS3KeyPrefix</span>: ssm_output/
</code></pre></div><h3 id=terraform-automation-documents>Terraform automation documents</h3><p>We can deploy these to AWS using Terraform once again. Note that the <code>document_type</code> is <code>Automation</code> and that we&rsquo;re using templating to set the variables in the document, such as referencing the PerformHealthcheckS3 command document ARN.</p><p>You can see the templated version of the document in <a href=https://github.com/jdheyburn/terraform-examples/blob/main/aws-ssm-automation-2/documents/patch_with_healthcheck_template.yml>GitHub</a>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=color:#ff79c6>resource</span> <span style=color:#f1fa8c>&#34;aws_ssm_document&#34; &#34;patch_with_healthcheck&#34;</span> {
  name            <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;PatchWithHealthcheck&#34;</span>
  document_type   <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;Automation&#34;</span>
  document_format <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;YAML&#34;</span>

  content <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>templatefile</span>(
    <span style=color:#f1fa8c>&#34;documents/patch_with_healthcheck_template.yml&#34;</span>,
    {
      healthcheck_document_arn <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>aws_ssm_document</span>.<span style=color:#ff79c6>perform_healthcheck_s3</span>.<span style=color:#ff79c6>arn</span>,
      output_s3_bucket_name    <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>aws_s3_bucket</span>.<span style=color:#ff79c6>script_bucket</span>.<span style=color:#ff79c6>id</span>,
      output_s3_key_prefix     <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;ssm_output/&#34;</span>,
    }
  )
}
</code></pre></div><p>View the above resource in <a href=https://github.com/jdheyburn/terraform-examples/blob/main/aws-ssm-automation-2/ssm_combined_command.tf>GitHub</a>.</p><h3 id=testing-automation-documents>Testing automation documents</h3><p>Now let&rsquo;s go and test this by manually invoking it. This can be done by navigating to <a href=https://console.aws.amazon.com/systems-manager/automation/executions>Automation</a> within Systems Manager and clicking <a href=https://console.aws.amazon.com/systems-manager/automation/execute>Execute Automation</a>.</p><blockquote><p>For a shortcut of invoking the commands, you can use the below command to invoke the below CLI command. Then you may skip to <a href=#results>the results</a>.</p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>aws ssm start-automation-execution <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --document-name <span style=color:#f1fa8c>&#34;PatchWithHealthcheck&#34;</span> <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --document-version <span style=color:#f1fa8c>&#34;\$DEFAULT&#34;</span> <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --target-parameter-name InstanceIds <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --max-errors <span style=color:#f1fa8c>&#34;0&#34;</span> <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --max-concurrency <span style=color:#f1fa8c>&#34;1&#34;</span> <span style=color:#f1fa8c>\
</span><span style=color:#f1fa8c></span>  --region eu-west-1
</code></pre></div><h4 id=setup>Setup</h4><p>Navigate to the <strong>Owned by me</strong> tab and select the name of your created document, <strong>PatchWithHealthcheck</strong>, then click <strong>Next</strong>.</p><p>Because we want to test this document executing one at a time on an instance, we&rsquo;ll need to select the <strong>Rate control</strong> option.</p><figure class=center><a href=execute-automation-1.png><img src=execute-automation-1.png alt="Execute automation document page for PatchHealthcheck, Rate Control is selected"></a></figure><p>We&rsquo;ll need to select what instances are our targets. The instances in scope for this document are <a href=https://github.com/jdheyburn/terraform-examples/blob/main/aws-ssm-automation-2/ec2.tf#L23>tagged</a> with the key <code>App</code> with the value <code>HelloWorld</code>, so let&rsquo;s use that as our criteria. Note this is the most scalable solution for targeting instances.</p><figure class=center><a href=execute-automation-2.png><img src=execute-automation-2.png alt="A screenshot of the execute automation page with tag key App and tag value HelloWorld specified"></a></figure><p>Then we need to specify how the rate of invocation should be controlled. Our criteria for this is:</p><ul><li>Execute on 1 instance at a time</li><li>Abort further invocations if any produce a error</li></ul><p>Therefore we need to set the concurrency to 1 and the error threshold to 0.</p><figure class=center><a href=execute-automation-3.png><img src=execute-automation-3.png alt="A screenshot of the execute automation page with concurrency set to 1 and the error threshold set to 0"></a></figure><p>Once all done then click <strong>Execute</strong>.</p><h4 id=results>Results</h4><p>As the execution progresses you&rsquo;ll notice it invokes the document on one instance at a time. As it completes you&rsquo;ll have a screen that looks like the below as you click onto the execution detail page. Notice that the start and end times of each instance invocation do not overlap with one another.</p><blockquote><p>Step name is the same as the instance ID in this case</p></blockquote><figure class=center><a href=execute-automation-4.png><img src=execute-automation-4.png alt="A screenshot of the successfully completed execution detail page, all executed steps across all instances are successful and did not overlap one another"></a></figure><p>We can dive into each step invocation (the blue text in the above screenshot) to view the commands that were invoked.</p><figure class=center><a href=execute-automation-5.png><img src=execute-automation-5.png alt="A screenshot of a successful automation step, there is a clickable URL for the step execution ID"></a></figure><figure class=center><a href=execute-automation-6.png><img src=execute-automation-6.png alt="A screenshot of a successful automation document PatchWithHealthcheck - both patching and healthcheck run command steps are successful"></a></figure><p>At this detail we can see the individual <code>aws:runCommand</code> actions performed on the instance.</p><h3 id=failure-testing>Failure testing</h3><p>Okay so we&rsquo;ve confirmed the document now only invokes synchronously. Let&rsquo;s now test to see if further invocations are aborted when there is a failure.</p><p>To simulate the failure, we can borrow a trick from the <a href=https://jdheyburn.co.uk/blog/automate-instance-hygiene-with-aws-ssm-0/#testing-in-aws-ssm-console>first post</a> in this series by flipping the healthcheck script from <code>></code> to <code>&lt;</code>. Once that change is deployed we can re-run the document using the same method as <a href=#testing-automation-documents>above</a>.</p><figure class=center><a href=failed-automation-1.png><img src=failed-automation-1.png alt="Simulating a failure, now the rate-limited automation document fails on the first instance invocation"></a></figure><p>We can see the failure, and that the automation did not invoke on more instances! We can drill down into the invocation to see why it failed.</p><figure class=center><a href=failed-automation-2.png><img src=failed-automation-2.png alt="The execution detail page for PatchWithHealthcheck, the patch event succeeded but the healthcheck is marked as failed"></a></figure><p>From this page you can then continue to drill down to the run command output to determine the cause of the failure.</p><h2 id=configuring-automation-tasks-for-maintenance-windows>Configuring automation tasks for maintenance windows</h2><p>Now that we&rsquo;ve tested the automation document and we&rsquo;re happy to have it automated, let&rsquo;s get this added to a maintenance window task. We can reuse the same maintenance window as we created last time, but with some differences.</p><h3 id=maintenance-window-task>Maintenance window task</h3><p>Since we are targeting an automation document, there are some differences we need to account for when compared to <a href=https://jdheyburn.co.uk/blog/automate-instance-hygiene-with-aws-ssm-1/#maintenance-window-tasks>command tasks</a>.</p><ol><li>Specify the <code>task_type</code> as <code>AUTOMATION</code></li><li>Update the <code>task_arn</code> to our new document accordingly</li><li>Ensure our new combined document is only invoked on one instance at a time, so <code>max_concurrency</code> is set to <code>1</code></li><li>Within <code>task_invocation_parameters</code> we use <code>automation_parameters</code> as opposed to <code>run_command_parameters</code>.<ul><li><code>document_version</code> allows us to target a specific document version</li><li>any parameters required by the document are defined within <code>parameter</code></li></ul></li></ol><p>Remember that our document takes in <code>InstanceIds</code> as a parameter? Well you&rsquo;ll notice that the value is set to <code>"{{ TARGET_ID }}"</code>. This is known in AWS as a <a href=https://docs.aws.amazon.com/systems-manager/latest/userguide/mw-cli-register-tasks-parameters.html>pseudo parameter</a>, whereby the instance ID returned by <code>WindowTargetIds</code> will be passed into the automation document.</p><blockquote><p>Depending on what <code>resource_type</code> your <code>aws_ssm_maintenance_window_target</code> is set up as will result in a different value to <code>{{ TARGET_ID }}</code> - in our case ours is <code>INSTANCE</code>, so this becomes the instance ID.</p><p>See the <a href=https://docs.aws.amazon.com/systems-manager/latest/userguide/mw-cli-register-tasks-parameters.html#pseudo-parameters>AWS docs</a> for a full breakdown.</p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=color:#ff79c6>resource</span> <span style=color:#f1fa8c>&#34;aws_ssm_maintenance_window_task&#34; &#34;patch_with_healthcheck&#34;</span> {
  window_id        <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>aws_ssm_maintenance_window</span>.<span style=color:#ff79c6>patch_with_healthcheck</span>.<span style=color:#ff79c6>id</span>
  task_type        <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;AUTOMATION&#34;</span>
  task_arn         <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>aws_ssm_document</span>.<span style=color:#ff79c6>patch_with_healthcheck</span>.<span style=color:#ff79c6>arn</span>
  priority         <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>10</span>
  service_role_arn <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>aws_iam_role</span>.<span style=color:#ff79c6>patch_mw_role</span>.<span style=color:#ff79c6>arn</span>

  max_concurrency <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;1&#34;</span>
  max_errors      <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;0&#34;</span>

  <span style=color:#ff79c6>targets</span> {
    key    <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;WindowTargetIds&#34;</span>
    values <span style=color:#ff79c6>=</span> [<span style=color:#ff79c6>aws_ssm_maintenance_window_target</span>.<span style=color:#ff79c6>patch_with_healthcheck_target</span>.<span style=color:#ff79c6>id</span>]
  }

  <span style=color:#ff79c6>task_invocation_parameters</span> {
    <span style=color:#ff79c6>automation_parameters</span> {
      document_version <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;$LATEST&#34;</span>

      <span style=color:#ff79c6>parameter</span> {
        name   <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;InstanceIds&#34;</span>
        values <span style=color:#ff79c6>=</span> [<span style=color:#f1fa8c>&#34;{{ TARGET_ID }}&#34;</span>]
      }
    }
  }
}
</code></pre></div><p>You can view the above resource in <a href=https://github.com/jdheyburn/terraform-examples/blob/main/aws-ssm-automation-2/maintenance_window.tf#L22>GitHub</a>.</p><h3 id=maintenance-window-target>Maintenance window target</h3><p>We need to update the target to use tag lookups against the instances - this mimics how we tested our automation document earlier on.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=color:#ff79c6>resource</span> <span style=color:#f1fa8c>&#34;aws_ssm_maintenance_window_target&#34; &#34;patch_with_healthcheck_target&#34;</span> {
  window_id     <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>aws_ssm_maintenance_window</span>.<span style=color:#ff79c6>patch_with_healthcheck</span>.<span style=color:#ff79c6>id</span>
  name          <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;PatchWithHealthcheckTargets&#34;</span>
  description   <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;All instances that should be patched with a healthcheck after&#34;</span>
  resource_type <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;INSTANCE&#34;</span>

  <span style=color:#ff79c6>targets</span> {
    key    <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;tag:App&#34;</span>
    values <span style=color:#ff79c6>=</span> [<span style=color:#f1fa8c>&#34;HelloWorld&#34;</span>]
  }
}
</code></pre></div><p>You can view the above resource in <a href=https://github.com/jdheyburn/terraform-examples/blob/main/aws-ssm-automation-2/maintenance_window.tf#L10>GitHub</a>.</p><h3 id=additional-iam-policies>Additional IAM policies</h3><p>We&rsquo;ll need to also attach some new permissions to the IAM role for the maintenance window, <code>aws_iam_role.patch_mw_role.arn</code>, to allow the automation document to perform a lookup on instances by their tag as defined in the updated <code>aws_ssm_maintenance_window_target.patch_with_healthcheck_target</code> resource.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=color:#ff79c6>data</span> <span style=color:#f1fa8c>&#34;aws_iam_policy_document&#34; &#34;mw_role_additional&#34;</span> {
  <span style=color:#ff79c6>statement</span> {
    sid    <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;AllowSSM&#34;</span>
    effect <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;Allow&#34;</span>

    actions <span style=color:#ff79c6>=</span> [
      <span style=color:#f1fa8c>&#34;ssm:DescribeInstanceInformation&#34;</span>,
      <span style=color:#f1fa8c>&#34;ssm:ListCommandInvocations&#34;</span>,
    ]

    resources <span style=color:#ff79c6>=</span> [<span style=color:#f1fa8c>&#34;*&#34;</span>]
  }
}

<span style=color:#ff79c6>resource</span> <span style=color:#f1fa8c>&#34;aws_iam_policy&#34; &#34;mw_role_add&#34;</span> {
  name        <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;MwRoleAdd&#34;</span>
  description <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;Additonal permissions needed for MW&#34;</span>

  policy <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>data</span>.<span style=color:#ff79c6>aws_iam_policy_document</span>.<span style=color:#ff79c6>mw_role_additional</span>.<span style=color:#ff79c6>json</span>
}

<span style=color:#ff79c6>resource</span> <span style=color:#f1fa8c>&#34;aws_iam_role_policy_attachment&#34; &#34;mw_role_add&#34;</span> {
  role       <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>aws_iam_role</span>.<span style=color:#ff79c6>patch_mw_role</span>.<span style=color:#ff79c6>name</span>
  policy_arn <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>aws_iam_policy</span>.<span style=color:#ff79c6>mw_role_add</span>.<span style=color:#ff79c6>arn</span>
}
</code></pre></div><p>You can view the above resources in <a href=https://github.com/jdheyburn/terraform-examples/blob/main/aws-ssm-automation-2/maintenance_window_iam.tf#L30>GitHub</a>.</p><p>Simply put, we&rsquo;re creating an new IAM policy with anything additional that the maintenance window requires for it to operate. We&rsquo;ll use this policy to add any new actions if we need to in the future.</p><h3 id=testing-automation-documents-in-maintenance-windows>Testing automation documents in maintenance windows</h3><p>Once you&rsquo;ve got the config above applied you&rsquo;ll need to run a test. Just like <a href=https://jdheyburn.co.uk/blog/automate-instance-hygiene-with-aws-ssm-1/#testing-the-barebones-maintenance-window>last time</a>, you can do this by changing the maintenance window execution time to something relatively close to your current time.</p><p>Once the execution is complete (and hopefully it was successful, if not then check back at the configuration), you&rsquo;ll see that there will be 3 task invocations, one for each instance, and that none of them overlapped one another.</p><figure class=center><a href=automation-maint-window-success.png><img src=automation-maint-window-success.png alt="Execution overview for the maintenance window invocation - we have 3 task invocations, one for each instance and all successful, for which only one was invoked at a time"></a><figcaption><p>Notice how the start and end times don&rsquo;t overlap</p></figcaption></figure><p>Just like for command documents, you can view the detail for each invocation made on the instance. Here we can see the two steps that make up our newly created command document.</p><figure class=center><a href=automation-maint-window-success-detail.png><img src=automation-maint-window-success-detail.png alt="Task invocation detail view for one instance. There are two steps, one for invoking a patch event and another for performing a healthcheck - both are successful"></a></figure><p>But the whole point of this exercise was to proactively handle errors right? So let&rsquo;s introduce some by doing what we&rsquo;ve done <a href=#failure-testing>before</a> and change the healthcheck script to fail.</p><p>Once the new &ldquo;broken&rdquo; script is applied we can rerun another test of the maintenance window.</p><figure class=center><a href=automation-maint-window-failure.png><img src=automation-maint-window-failure.png alt="Execution overview for the maintenance window invocation - we have 3 task invocations, one for each instance, 1 failed which then aborted further task invocations on the remaining instances"></a></figure><p>This time round we can see that there was a failure in one task invocation, which then aborted further invocations on the remaining instances! Just as before, we can do a deep dive into the invocation to determine why it had failed.</p><figure class=center><a href=automation-maint-window-failure-detail.png><img src=automation-maint-window-failure-detail.png alt="Task invocation detail view for one instance. There are two steps, one for invoking a patch event and another for performing a healthcheck - the patch was successful but the healthcheck failed"></a><figcaption><p>From here you can follow the command invoked by the step to troubleshoot the failure</p></figcaption></figure><h2 id=bonus-using-automation-to-dynamically-invoke-command-documents>Bonus: Using automation to dynamically invoke command documents</h2><p>In this post we&rsquo;ve looked at a common maintenance task in the form of an SSM command document called <strong>AWS-RunPatchBaseline</strong>, and created an automation document that will always invoke our healthcheck script after this invocation.</p><p>You may have more command documents that perform some form of maintenance on instances, for which you would also want the healthcheck script to execute after as well.</p><p>Instead of copying and pasting these automation documents, we can create just one automation document which takes in the command document ARN as a parameter, dynamically invoke it, and then have a hardcoded step afterward for executing a healthcheck!</p><p>In it&rsquo;s raw YAML form, we would get a document that looks like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
<span style=color:#ff79c6>schemaVersion</span>: <span style=color:#f1fa8c>&#34;0.3&#34;</span>
<span style=color:#ff79c6>description</span>: Executes a maintenance event on the instance followed by a healthcheck
<span style=color:#ff79c6>parameters</span>:
  <span style=color:#ff79c6>InstanceIds</span>:
    <span style=color:#ff79c6>type</span>: StringList
    <span style=color:#ff79c6>description</span>: The instance to target
  <span style=color:#ff79c6>DocumentArn</span>:
    <span style=color:#ff79c6>type</span>: String
    <span style=color:#ff79c6>description</span>: The document arn to invoke
  <span style=color:#ff79c6>InputParameters</span>:
    <span style=color:#ff79c6>type</span>: StringMap
    <span style=color:#ff79c6>description</span>: Parameters that should be passed to the document specified in DocumentArn
    <span style=color:#ff79c6>default</span>: {}
<span style=color:#ff79c6>mainSteps</span>:
  - <span style=color:#ff79c6>name</span>: InvokeMaintenanceEvent
    <span style=color:#ff79c6>action</span>: aws:runCommand
    <span style=color:#ff79c6>inputs</span>:
      <span style=color:#ff79c6>DocumentName</span>: <span style=color:#f1fa8c>&#34;{{ DocumentArn }}&#34;</span>
      <span style=color:#ff79c6>InstanceIds</span>: <span style=color:#f1fa8c>&#34;{{ InstanceIds }}&#34;</span>
      <span style=color:#ff79c6>OutputS3BucketName</span>: ${output_s3_bucket_name}
      <span style=color:#ff79c6>OutputS3KeyPrefix</span>: ${output_s3_key_prefix}
      <span style=color:#ff79c6>Parameters</span>: <span style=color:#f1fa8c>&#34;{{ InputParameters }}&#34;</span>
  - <span style=color:#ff79c6>name</span>: ExecuteHealthcheck
    <span style=color:#ff79c6>action</span>: aws:runCommand
    <span style=color:#ff79c6>inputs</span>:
      <span style=color:#ff79c6>DocumentName</span>: ${healthcheck_document_arn}
      <span style=color:#ff79c6>InstanceIds</span>: <span style=color:#f1fa8c>&#34;{{ InstanceIds }}&#34;</span>
      <span style=color:#ff79c6>OutputS3BucketName</span>: ${output_s3_bucket_name}
      <span style=color:#ff79c6>OutputS3KeyPrefix</span>: ${output_s3_key_prefix}
</code></pre></div><p>Just like what we&rsquo;ve done for <code>InstanceIds</code>, we&rsquo;re taking in the <code>DocumentArn</code> as a parameter and providing it as the input for the <code>aws:runCommand</code> step. Some documents will also take parameters, so we can allow the caller to specify them using <code>InputParameters</code>, which is defined as a <code>StringMap</code> type - allowing it to then be used in as parameters for the document we are invoking.</p><p>When we create this document in the console and then execute it, we can then dynamically add in the document we want to invoke.</p><figure class=center><a href=maintenance-wrapper-setup.png><img src=maintenance-wrapper-setup.png alt="The setup page for the maintenance wrapper document, we're specifying in the text field the command document to invoke, which is AWS-RunPatchBaseline. We've also added in the parameters for the document to run under InputParameters"></a></figure><p>Then just like any other document we can invoke it.</p><figure class=center><a href=maintenance-wrapper-success.png><img src=maintenance-wrapper-success.png alt="The automation execution overview page shows that two steps were invoked, InvokeMaintenanceEvent and ExecuteHealthcheck, both are successful. We can also see the input for InvokeMaintenanceEvent is specified as AWS-RunPatchBaseline, and the parameters we used previously."></a></figure><p>We can see that the input from the previous screen was passed to the step. Let&rsquo;s keep going until we hit the command invocation.</p><figure class=center><a href=maintenance-wrapper-command-detail.png><img src=maintenance-wrapper-command-detail.png alt="A screenshot of the command invocation page - it executed successfully and the document listed as being invoked was AWS-RunPatchBaseline"></a><figcaption><p>The document name was dynamically passed to the command execution</p></figcaption></figure><h3 id=terraforming-dynamic-command-documents>Terraforming dynamic command documents</h3><p>So now we&rsquo;ve confirmed that documents can be dynamically invoked, let&rsquo;s get this Terraformed. You can view this in <a href=https://github.com/jdheyburn/terraform-examples/blob/main/aws-ssm-automation-2/ssm_maintenance_document.tf>GitHub</a>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=color:#ff79c6>resource</span> <span style=color:#f1fa8c>&#34;aws_ssm_document&#34; &#34;maintenance_wrapper&#34;</span> {
  name            <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;MaintenanceWithHealthcheck&#34;</span>
  document_type   <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;Automation&#34;</span>
  document_format <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;YAML&#34;</span>

  content <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>templatefile</span>(
    <span style=color:#f1fa8c>&#34;documents/maintenance_wrapper_template.yml&#34;</span>,
    {
      healthcheck_document_arn <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>aws_ssm_document</span>.<span style=color:#ff79c6>perform_healthcheck_s3</span>.<span style=color:#ff79c6>arn</span>,
      output_s3_bucket_name    <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>aws_s3_bucket</span>.<span style=color:#ff79c6>script_bucket</span>.<span style=color:#ff79c6>id</span>,
      output_s3_key_prefix     <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;ssm_output/&#34;</span>,
    }
  )
}
</code></pre></div><p>Not a lot has really changed in this when we compare it to our <a href=https://github.com/jdheyburn/terraform-examples/blob/main/aws-ssm-automation-2/ssm_combined_command.tf>one from earlier</a>, but the difference is in the <code>parameters</code> field for the <a href=https://github.com/jdheyburn/terraform-examples/blob/main/aws-ssm-automation-2/documents/maintenance_wrapper_template.yml>document</a>.</p><p>And then you can include it as a maintenance window task as below; I&rsquo;m reusing the same maintenance window task as before.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=color:#ff79c6>resource</span> <span style=color:#f1fa8c>&#34;aws_ssm_maintenance_window_task&#34; &#34;patch_with_healthcheck&#34;</span> {
  window_id        <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>aws_ssm_maintenance_window</span>.<span style=color:#ff79c6>patch_with_healthcheck</span>.<span style=color:#ff79c6>id</span>
  task_type        <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;AUTOMATION&#34;</span>
  task_arn         <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>aws_ssm_document</span>.<span style=color:#ff79c6>maintenance_wrapper</span>.<span style=color:#ff79c6>arn</span>
  priority         <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>10</span>
  service_role_arn <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>aws_iam_role</span>.<span style=color:#ff79c6>patch_mw_role</span>.<span style=color:#ff79c6>arn</span>

  max_concurrency <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;1&#34;</span>
  max_errors      <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;0&#34;</span>

  <span style=color:#ff79c6>targets</span> {
    key    <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;WindowTargetIds&#34;</span>
    values <span style=color:#ff79c6>=</span> [<span style=color:#ff79c6>aws_ssm_maintenance_window_target</span>.<span style=color:#ff79c6>patch_with_healthcheck_target</span>.<span style=color:#ff79c6>id</span>]
  }

  <span style=color:#ff79c6>task_invocation_parameters</span> {
    <span style=color:#ff79c6>automation_parameters</span> {
      document_version <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;$LATEST&#34;</span>

      <span style=color:#ff79c6>parameter</span> {
        name   <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;InstanceIds&#34;</span>
        values <span style=color:#ff79c6>=</span> [<span style=color:#f1fa8c>&#34;{{ TARGET_ID }}&#34;</span>]
      }

      <span style=color:#ff79c6>parameter</span> {
        name   <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;DocumentArn&#34;</span>
        values <span style=color:#ff79c6>=</span> [<span style=color:#f1fa8c>&#34;AWS-RunPatchBaseline&#34;</span>]
      }

      <span style=color:#ff79c6>parameter</span> {
        name   <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;InputParameters&#34;</span>
        values <span style=color:#ff79c6>=</span> [jsonencode({ Operation <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;Scan&#34;</span> })]
      }
    }
  }
}
</code></pre></div><p>You can then copy and paste the same task resource, only changing the values for the <code>InputParameters</code> and <code>DocumentArn</code> parameters accordingly. If the document you are calling doesn&rsquo;t take any parameters, then you can just omit that block.</p><blockquote><p>You&rsquo;ll have to ensure that the IAM role the maintenance window task is assuming has the correct IAM permissions as required by the document you&rsquo;re calling.</p></blockquote><h2 id=conclusion>Conclusion</h2><p>What we&rsquo;ve done in this post is taken our rudimentary command document, prone to introducing errors into our estate, and converted it to an automation document. With the right SSM maintenance window settings, you can ensure that any maintenance tasks you need to perform on your EC2 instances are done so in a manner that reduces the risk of errors in your environment.</p><p>Next time, we&rsquo;ll be taking this a <em>step further</em> to proactively remove EC2 instances from circulation when behind a load balancer for maintenance activities.</p></div><footer><section class=see-also><h3>See also in Automate Instance Hygiene with AWS SSM</h3><nav><ul><li><a href=https://jdheyburn.co.uk/blog/automate-instance-hygiene-with-aws-ssm-3/>How to automate zero downtime maintenance with AWS SSM & ALBs</a></li><li><a href=https://jdheyburn.co.uk/blog/automate-instance-hygiene-with-aws-ssm-1/>Automate Instance Hygiene with AWS SSM: Maintenance Windows</a></li><li><a href=https://jdheyburn.co.uk/blog/automate-instance-hygiene-with-aws-ssm-0/>Automate Instance Hygiene with AWS SSM: Command Documents</a></li></ul></nav></section></footer></article></section></div><footer class=footer><section class=container>©
2022
Joseph D. Heyburn
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main></body></html>