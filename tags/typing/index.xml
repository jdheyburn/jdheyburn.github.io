<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>typing on JDHeyburn</title><link>https://jdheyburn.co.uk/tags/typing/</link><description>Recent content in typing on JDHeyburn</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 05 Jul 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://jdheyburn.co.uk/tags/typing/index.xml" rel="self" type="application/rss+xml"/><item><title>Three Ways To Spice Up Your Python Code</title><enclosure url="https://jdheyburn.co.uk/images/jdheyburn_co_uk_card.png" type="image/jpg"/><link>https://jdheyburn.co.uk/blog/three-ways-to-spice-up-your-python-code/</link><pubDate>Fri, 05 Jul 2019 00:00:00 +0000</pubDate><guid>https://jdheyburn.co.uk/blog/three-ways-to-spice-up-your-python-code/</guid><description>&lt;h2 id="spice-up-your-life-python-">Spice Up Your &lt;del>Life&lt;/del> Python ðŸ&lt;/h2>
&lt;p>I&amp;rsquo;m currently working on a side project that I&amp;rsquo;ve written in Python. Now I&amp;rsquo;ve have a lot of experience with Python before, I used it primarily to write a load of scripts for automating processes for when Bash didn&amp;rsquo;t quite cut it. Don&amp;rsquo;t get me wrong Bash is great, but like for every other language out there, each has its purpose in the world.&lt;/p>
&lt;p>My experience with Python didn&amp;rsquo;t go beyond setting some variables, hitting endpoints, executing some Bash commands to install some vendor components. All of which is what makes Python so great right? Implying on types is useful for some cases. In fact this reminds me of a tweet I saw, I can&amp;rsquo;t find it again but it went something like this:&lt;/p>
&lt;blockquote>
&lt;p>Stages of learning programming:&lt;/p>
&lt;ol>
&lt;li>Learn a typed language, such as Java - complain at its complexity&lt;/li>
&lt;li>Learn an untyped language, such as JavaScript or Python - marvel at its simplicity&lt;/li>
&lt;li>Get frustrated at implied types in step 2&lt;/li>
&lt;li>Revert to step 1&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>During said experiences I came across some poorly written scripts whiched &lt;strong>triggered&lt;/strong> some pet peeves: what object a function is expecting, or what it returns? Did I break some downstream function? This made it terribly difficult to add new functionality to scripts.&lt;/p>
&lt;p>With this side project I wanted to make it right from the start. So I said to myself these are the key areas I want to target:&lt;/p>
&lt;ol>
&lt;li>The application must be extensively tested (did I mention I &lt;a href="https://jdheyburn.co.uk/posts/extending-gotests-for-strict-error-tests/">love tests?&lt;/a>)&lt;/li>
&lt;li>Functions must clearly define what the type of the objects the parameters are, and what the types of the objects they return are.&lt;/li>
&lt;li>&lt;del>Best&lt;/del> Practices are upheld throughout the way&lt;/li>
&lt;/ol>
&lt;p>From this list, we can include the following to solve the above:&lt;/p>
&lt;ol>
&lt;li>&lt;a href="#tests">Tests!!&lt;/a>&lt;/li>
&lt;li>&lt;a href="#static-type-checking">Static type checking&lt;/a>&lt;/li>
&lt;li>&lt;a href="#class-objects">Classes&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="tests">Tests&lt;/h2>
&lt;p>Alright so I know this one is a given. But in all honesty I&amp;rsquo;ve never really tested Python code before. Why so? I found it difficult to mock API calls and the effort required for the initial learning curve didn&amp;rsquo;t seem to pay off for the tiny script I was automating. Given the scope of my side project is rather large, this is a great opportunity to learn. Let&amp;rsquo;s start with a basic function:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#6272a4"># scratch.py&lt;/span>
&lt;span style="color:#ff79c6">def&lt;/span> &lt;span style="color:#50fa7b">increment_int_by_one&lt;/span>(int_to_inc):
incremented_int &lt;span style="color:#ff79c6">=&lt;/span> int_to_increment &lt;span style="color:#ff79c6">+&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>
&lt;span style="color:#ff79c6">return&lt;/span> incremented_int
&lt;/code>&lt;/pre>&lt;/div>&lt;p>While this is something easy enough to test by doing so manually, at some point its functionality may increase, and at that point we would require automated tests to ensure its original feature-set was unchanged.&lt;/p>
&lt;h3 id="implementation">Implementation&lt;/h3>
&lt;p>There are &lt;a href="https://wiki.python.org/moin/PythonTestingToolsTaxonomy">several testing frameworks&lt;/a> out there, but for my use case I am using the built-in &lt;code>unittest&lt;/code> which is easy enough to use. A basic structure of a test file is seen below:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#6272a4"># test_scratch.py&lt;/span>
&lt;span style="color:#ff79c6">import&lt;/span> unittest
&lt;span style="color:#ff79c6">import&lt;/span> scratch
&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">TestIncrement&lt;/span>(unittest&lt;span style="color:#ff79c6">.&lt;/span>TestCase):
&lt;span style="color:#ff79c6">def&lt;/span> &lt;span style="color:#50fa7b">test_increment&lt;/span>(self):
&lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;span style="color:#f1fa8c"> Should successfully return int value 2
&lt;/span>&lt;span style="color:#f1fa8c"> Given a parameter of int value 1
&lt;/span>&lt;span style="color:#f1fa8c"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
expected &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">2&lt;/span>
int_to_inc &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>
actual &lt;span style="color:#ff79c6">=&lt;/span> scratch&lt;span style="color:#ff79c6">.&lt;/span>increment_int_by_one(int_to_inc)
self&lt;span style="color:#ff79c6">.&lt;/span>assertEqual(actual, expected)
&lt;span style="color:#ff79c6">if&lt;/span> __name__ &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;__main__&amp;#39;&lt;/span>:
unittest&lt;span style="color:#ff79c6">.&lt;/span>main()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>There&amp;rsquo;s a lot going on here, let&amp;rsquo;s break it down by section.&lt;/p>
&lt;h4 id="imports">Imports&lt;/h4>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#ff79c6">import&lt;/span> unittest
&lt;span style="color:#ff79c6">import&lt;/span> scratch
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here we are specifying the modules that the test file is going to interact with. &lt;code>unittest&lt;/code> is the testing framework and &lt;code>scratch&lt;/code> is the Python file containing our business logic, as written earlier.&lt;/p>
&lt;h4 id="class-declaration">Class Declaration&lt;/h4>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">TestIncrement&lt;/span>(unittest&lt;span style="color:#ff79c6">.&lt;/span>TestCase):
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Simply enough, this is a class that extends the &lt;code>unittest.TestCase&lt;/code> class, for which then unittest can then execute all the test methods defined within it, and you can name them like &lt;code>class TestXXXX&lt;/code>. There is no limit to how many classes you can have, but I like to group my TestClasses together in terms of what logic they are testing.&lt;/p>
&lt;h4 id="test-methods">Test Methods&lt;/h4>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#ff79c6">def&lt;/span> &lt;span style="color:#50fa7b">test_increment&lt;/span>(self):
&lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;span style="color:#f1fa8c"> Should successfully return int value 2
&lt;/span>&lt;span style="color:#f1fa8c"> Given a parameter of int value 1
&lt;/span>&lt;span style="color:#f1fa8c"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
expected &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">2&lt;/span>
int_to_inc &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>
actual &lt;span style="color:#ff79c6">=&lt;/span> scratch&lt;span style="color:#ff79c6">.&lt;/span>increment_int_by_one(int_to_inc)
self&lt;span style="color:#ff79c6">.&lt;/span>assertEqual(actual, expected)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>These methods are the real juicy bits of your tests. Here you are defining the parameters that are going to be used by your functions, and hitting the logic you are testing. For each test that you write you will alter the test name, description, expected values, and input parameters accordingly to what you are testing.&lt;/p>
&lt;h4 id="main-method-invocation">Main Method Invocation&lt;/h4>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#ff79c6">if&lt;/span> __name__ &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;__main__&amp;#39;&lt;/span>:
unittest&lt;span style="color:#ff79c6">.&lt;/span>main()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>To close off nice and easily, this will tell Python to invoke all test classes that are described within &lt;code>unittest.TestCase&lt;/code>.&lt;/p>
&lt;h3 id="execution">Execution&lt;/h3>
&lt;p>Now just execute the test file and it will now run as expected:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> python &lt;span style="color:#ff79c6">-&lt;/span>m unittest test_scratch
&lt;span style="color:#ff79c6">.&lt;/span>
&lt;span style="color:#ff79c6">----------------------------------------------------------------------&lt;/span>
Ran &lt;span style="color:#bd93f9">1&lt;/span> test &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#bd93f9">0.001&lt;/span>s
OK
&lt;/code>&lt;/pre>&lt;/div>&lt;p>A nice little touch is that we don&amp;rsquo;t even need to provide &lt;code>-m unittest&lt;/code> to the Python intepreter since we have defined the main method invocation:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> python test_scratch&lt;span style="color:#ff79c6">.&lt;/span>py
&lt;span style="color:#ff79c6">.&lt;/span>
&lt;span style="color:#ff79c6">----------------------------------------------------------------------&lt;/span>
Ran &lt;span style="color:#bd93f9">1&lt;/span> test &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#bd93f9">0.002&lt;/span>s
OK
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="static-type-checking">Static Type Checking&lt;/h2>
&lt;p>As I mentioned before, Python is great for throwing together a script to automate some task. It&amp;rsquo;s quick and easy to do mainly because the type of a variable is implied from whatever you set to it.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#ff79c6">&amp;gt;&amp;gt;&amp;gt;&lt;/span> my_int_var &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>
&lt;span style="color:#ff79c6">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">type&lt;/span>(my_int_var)
&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span> &amp;#39;&lt;span style="color:#50fa7b">int&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This also applies to functions that take in a parameter, the type for it is implied from what it receives! Let&amp;rsquo;s revisit our incrementing function from earlier:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#ff79c6">def&lt;/span> &lt;span style="color:#50fa7b">increment_int_by_one&lt;/span>(int_to_inc):
incremented_int &lt;span style="color:#ff79c6">=&lt;/span> int_to_increment &lt;span style="color:#ff79c6">+&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>
&lt;span style="color:#ff79c6">return&lt;/span> incremented_int
&lt;span style="color:#ff79c6">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">print&lt;/span>(increment_int_by_one(&lt;span style="color:#bd93f9">1&lt;/span>))
&lt;span style="color:#bd93f9">2&lt;/span>
&lt;span style="color:#ff79c6">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">print&lt;/span>(increment_int_by_one(&lt;span style="color:#bd93f9">100&lt;/span>))
&lt;span style="color:#bd93f9">101&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>All good so far. But what happens when we pass in something that is not an int, such as a string?&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#ff79c6">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">print&lt;/span>(increment_int_by_one(&lt;span style="color:#f1fa8c">&amp;#34;1&amp;#34;&lt;/span>))
Traceback (most recent call last):
File &lt;span style="color:#f1fa8c">&amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;&lt;/span>, line &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#ff79c6">&amp;lt;&lt;/span>module&lt;span style="color:#ff79c6">&amp;gt;&lt;/span>
File &lt;span style="color:#f1fa8c">&amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;&lt;/span>, line &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#ff79c6">in&lt;/span> increment_int_by_one
TypeError: must be &lt;span style="color:#8be9fd;font-style:italic">str&lt;/span>, &lt;span style="color:#ff79c6">not&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">int&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Yikes, that&amp;rsquo;s a misleading error! Having a look at the error straight away, you&amp;rsquo;d be confused at &amp;lsquo;what&amp;rsquo; must be a string, not an int - didn&amp;rsquo;t you accidentally provide a str? So why is it telling us it must be a str and not an int?&lt;/p>
&lt;p>What this is actually error-ing on is how an int is being concatenated to a str on the left-hand side of the + operator.&lt;/p>
&lt;blockquote>
&lt;p>Under the hood, Python believe you are trying to do a &lt;strong>string concatenation&lt;/strong> because the parameter is of type string, and is on the left-hand side of the + operator. The below shows a valid way to perform a string concatenation:&lt;/p>
&lt;p>&lt;code>&amp;quot;1&amp;quot; + &amp;quot;1&amp;quot; # -&amp;gt; &amp;quot;11&amp;quot;&lt;/code>&lt;/p>
&lt;p>If the int value was on the left-hand side of the operator and you passed a string, you&amp;rsquo;d get something like this:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-fallback" data-lang="fallback">&amp;gt;&amp;gt; 1 + &amp;#34;1&amp;#34;
Traceback (most recent call last):
File &amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;, line 1, in &amp;lt;module&amp;gt;
TypeError: unsupported operand type(s) for +: &amp;#39;int&amp;#39; and &amp;#39;str&amp;#39;
&lt;/code>&lt;/pre>&lt;/div>&lt;/blockquote>
&lt;p>But changing the right-side of the operator won&amp;rsquo;t fix this for us. What we need is to implement typing.&lt;/p>
&lt;h3 id="implementation-1">Implementation&lt;/h3>
&lt;p>Python 3.6 onwards introduced static type checking, so make sure you upgrade to it if you haven&amp;rsquo;t already - which you might want to do very soon as Python 2 is &lt;a href="https://pythonclock.org/">EOL in 2020&lt;/a>!&lt;/p>
&lt;p>Taking our above &lt;code>increment_int_by_one&lt;/code> function, we can add &lt;code>: int&lt;/code> to the parameter which will tell the function what type it expects the parameter to be.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#ff79c6">def&lt;/span> &lt;span style="color:#50fa7b">increment_int_by_one&lt;/span>(int_to_inc: &lt;span style="color:#8be9fd;font-style:italic">int&lt;/span>):
incremented_int &lt;span style="color:#ff79c6">=&lt;/span> int_to_increment &lt;span style="color:#ff79c6">+&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>
&lt;span style="color:#ff79c6">return&lt;/span> incremented_int
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now when we pass in a &lt;code>str&lt;/code> as the parameter, we still get the same error we saw before. However, if the IDE you are using supports it, you will receive &lt;strong>type hints&lt;/strong>!&lt;/p>
&lt;figure class="center">&lt;a href="type_hinting.png">
&lt;img src="type_hinting.png"
alt="Screenshot displaying type hinting provided by Visual Studio Code"/> &lt;/a>
&lt;/figure>
&lt;p>I&amp;rsquo;m using VSCode with the Python extension installed too, you can see the hint that appears includes the type of the parameter.&lt;/p>
&lt;p>VSCode also has the ability to check the type of the value you are passing into the function:&lt;/p>
&lt;figure class="center">&lt;a href="type_checking.png">
&lt;img src="type_checking.png"
alt="Screenshot displaying type checking provided by Visual Studio Code - the illegal type is highlighted by pyright"/> &lt;/a>
&lt;/figure>
&lt;p>Here we have a visual indicator that the string is incompatible with the int type of the function. Alongside this, in the Problems tab we have a full explanation on what has gone wrong. This is both provided by the &lt;code>pyright&lt;/code> extension which can be found in the VSCode Extensions section.&lt;/p>
&lt;h3 id="return-types">Return Types&lt;/h3>
&lt;p>So all of that just describes how typing works for parameters, but how can we specify the return type of a function? That is done easily enough too. Let&amp;rsquo;s extend on our increment function from earlier.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#ff79c6">def&lt;/span> &lt;span style="color:#50fa7b">increment_int_by_one&lt;/span>(int_to_inc: &lt;span style="color:#8be9fd;font-style:italic">int&lt;/span>) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">int&lt;/span>:
incremented_int &lt;span style="color:#ff79c6">=&lt;/span> int_to_inc &lt;span style="color:#ff79c6">+&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>
&lt;span style="color:#ff79c6">return&lt;/span> incremented_int
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Note the only change here is the &lt;code>-&amp;gt; int&lt;/code> which specifies the type it is returning. Now our type checker will highlight to us when we violate this in two scenarios:&lt;/p>
&lt;figure class="center">&lt;a href="type_checking_bad_return.png">
&lt;img src="type_checking_bad_return.png"
alt="Screenshot displaying type checking, highlighting the bad return value"/> &lt;/a>
&lt;/figure>
&lt;p>The IDE has shown us that the function is expected to return a type different to what it is actually returning&amp;hellip;&lt;/p>
&lt;figure class="center">&lt;a href="type_checking_bad_assign.png">
&lt;img src="type_checking_bad_assign.png"
alt="Screenshot displaying type checking, highlighting the bad assigned variable"/> &lt;/a>
&lt;/figure>
&lt;p>And in this snapshot, we are trying to assign a variable of type &lt;code>str&lt;/code> to the output of the function which returns an &lt;code>int&lt;/code>!&lt;/p>
&lt;p>Another pattern you might see is if a method does not return anything (in Java-speak, it is &lt;code>void&lt;/code>), an example of this is if the method is a constructor for a class.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#ff79c6">def&lt;/span> __init__(self) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> None:
self&lt;span style="color:#ff79c6">.&lt;/span>attribute &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;DEFAULT_VALUE&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="class-objects">Class Objects&lt;/h2>
&lt;p>So you might &lt;strong>class&lt;/strong> this (pardon the pun!) as a type of its own, but this is something I&amp;rsquo;ve learnt all the same recently, so I hope it benefits you too! Python has the ability to construct more complex objects in the form of classes. While I won&amp;rsquo;t go into the details of that (I&amp;rsquo;ll leave it up to &lt;a href="https://www.w3schools.com/python/python_classes.asp">better resources&lt;/a>), I wanted to show how I&amp;rsquo;ve been able to utilise them.&lt;/p>
&lt;h3 id="test-mocks">Test Mocks&lt;/h3>
&lt;p>One of the main reasons for implementing classes has been to resolve one of my requirements I described earlier on in this post, the ability to test my code easily. For my side project I interface with some third-party APIs to retrieve data, in order for me to test these I need to mock them appropriately. See below for a snippet of the code:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#6272a4"># spotify.py&lt;/span>
&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">SpApi&lt;/span>():
client: spotipy&lt;span style="color:#ff79c6">.&lt;/span>Spotify
&lt;span style="color:#ff79c6">def&lt;/span> __init__(self, &lt;span style="color:#8be9fd;font-style:italic">id&lt;/span>: &lt;span style="color:#8be9fd;font-style:italic">str&lt;/span>, secret: &lt;span style="color:#8be9fd;font-style:italic">str&lt;/span>) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> None:
ccm &lt;span style="color:#ff79c6">=&lt;/span> SpotifyClientCredentials(
client_id&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">id&lt;/span>,
client_secret&lt;span style="color:#ff79c6">=&lt;/span>secret
)
self&lt;span style="color:#ff79c6">.&lt;/span>client &lt;span style="color:#ff79c6">=&lt;/span> spotipy&lt;span style="color:#ff79c6">.&lt;/span>Spotify(client_credentials_manager&lt;span style="color:#ff79c6">=&lt;/span>ccm)
&lt;span style="color:#ff79c6">def&lt;/span> &lt;span style="color:#50fa7b">get_album_by_id&lt;/span>(self, &lt;span style="color:#8be9fd;font-style:italic">id&lt;/span>: &lt;span style="color:#8be9fd;font-style:italic">str&lt;/span>) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> SpAlbum:
&lt;span style="color:#ff79c6">return&lt;/span> SpAlbum(self&lt;span style="color:#ff79c6">.&lt;/span>client&lt;span style="color:#ff79c6">.&lt;/span>album(&lt;span style="color:#8be9fd;font-style:italic">id&lt;/span>))
&lt;span style="color:#ff79c6">def&lt;/span> &lt;span style="color:#50fa7b">query_album_by_title&lt;/span>(self, title: &lt;span style="color:#8be9fd;font-style:italic">str&lt;/span>) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> SpQueryRespWrapper:
q &lt;span style="color:#ff79c6">=&lt;/span> SpQueryBuilder(album&lt;span style="color:#ff79c6">=&lt;/span>title)&lt;span style="color:#ff79c6">.&lt;/span>build()
&lt;span style="color:#ff79c6">return&lt;/span> self&lt;span style="color:#ff79c6">.&lt;/span>execute_query(q)
&lt;span style="color:#ff79c6">def&lt;/span> &lt;span style="color:#50fa7b">query_album_by_title_and_artist&lt;/span>(self,
title: &lt;span style="color:#8be9fd;font-style:italic">str&lt;/span>,
artist: &lt;span style="color:#8be9fd;font-style:italic">str&lt;/span>) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> SpQueryRespWrapper:
q &lt;span style="color:#ff79c6">=&lt;/span> SpQueryBuilder(album&lt;span style="color:#ff79c6">=&lt;/span>title, album_artist&lt;span style="color:#ff79c6">=&lt;/span>artist)&lt;span style="color:#ff79c6">.&lt;/span>build()
&lt;span style="color:#ff79c6">return&lt;/span> self&lt;span style="color:#ff79c6">.&lt;/span>execute_query(q)
&lt;span style="color:#ff79c6">def&lt;/span> &lt;span style="color:#50fa7b">execute_query&lt;/span>(self, q: &lt;span style="color:#8be9fd;font-style:italic">str&lt;/span>) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> SpQueryRespWrapper:
&lt;span style="color:#ff79c6">return&lt;/span> SpQueryRespWrapper(self&lt;span style="color:#ff79c6">.&lt;/span>client&lt;span style="color:#ff79c6">.&lt;/span>search(q&lt;span style="color:#ff79c6">=&lt;/span>q, &lt;span style="color:#8be9fd;font-style:italic">type&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;album&amp;#39;&lt;/span>))
&lt;/code>&lt;/pre>&lt;/div>&lt;p>You might have guessed it, the API is Spotify&amp;rsquo;s, and I am using the &lt;a href="https://github.com/plamere/spotipy">spotipy&lt;/a> library to do the interfacing. The &lt;code>SpApi&lt;/code> class is essentially a wrapper around the client to allow me to easily re-use methods across the app. It&amp;rsquo;s usage would be &lt;code>sp_api = SpApi()&lt;/code>, which would return us a client available at &lt;code>sp_api.client&lt;/code>. It is this attribute of the class which we want the ability to mock for when we test it. See how I implemented the mock:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#6272a4"># test_spotify.py&lt;/span>
&lt;span style="color:#ff79c6">import&lt;/span> unittest
&lt;span style="color:#ff79c6">from&lt;/span> unittest.mock &lt;span style="color:#ff79c6">import&lt;/span> MagicMock
&lt;span style="color:#ff79c6">import&lt;/span> munch
&lt;span style="color:#ff79c6">import&lt;/span> spotify
get_album_by_id_response_fname &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;sp_get_album_by_id.json&amp;#39;&lt;/span>
&lt;span style="color:#ff79c6">with&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">open&lt;/span>(get_album_by_id_response_fname, &lt;span style="color:#f1fa8c">&amp;#39;r&amp;#39;&lt;/span>, encoding&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;utf-8&amp;#39;&lt;/span>) &lt;span style="color:#ff79c6">as&lt;/span> f:
get_album_by_id_response &lt;span style="color:#ff79c6">=&lt;/span> json&lt;span style="color:#ff79c6">.&lt;/span>load(f)
&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">TestSpApiClass&lt;/span>(unittest&lt;span style="color:#ff79c6">.&lt;/span>TestCase):
&lt;span style="color:#ff79c6">def&lt;/span> &lt;span style="color:#50fa7b">get_mock_sp_api&lt;/span>(self) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> spotify&lt;span style="color:#ff79c6">.&lt;/span>SpApi:
mock_sp_api &lt;span style="color:#ff79c6">=&lt;/span> spotify&lt;span style="color:#ff79c6">.&lt;/span>SpApi(&lt;span style="color:#f1fa8c">&amp;#39;id&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;secret&amp;#39;&lt;/span>)
mocked_album &lt;span style="color:#ff79c6">=&lt;/span> MagicMock(return_value&lt;span style="color:#ff79c6">=&lt;/span>get_album_by_id_response)
mock_sp_api&lt;span style="color:#ff79c6">.&lt;/span>client &lt;span style="color:#ff79c6">=&lt;/span> MagicMock(album&lt;span style="color:#ff79c6">=&lt;/span>mocked_album)
&lt;span style="color:#ff79c6">return&lt;/span> mock_sp_api
&lt;span style="color:#ff79c6">def&lt;/span> &lt;span style="color:#50fa7b">test_get_album_by_id&lt;/span>(self):
&lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;span style="color:#f1fa8c"> Given a request is made to Spotify API for Album ID
&lt;/span>&lt;span style="color:#f1fa8c"> Should verify that the API is hit
&lt;/span>&lt;span style="color:#f1fa8c"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
mock_sp_api &lt;span style="color:#ff79c6">=&lt;/span> self&lt;span style="color:#ff79c6">.&lt;/span>get_mock_sp_api()
expected &lt;span style="color:#ff79c6">=&lt;/span> spotify&lt;span style="color:#ff79c6">.&lt;/span>SpAlbum(munch&lt;span style="color:#ff79c6">.&lt;/span>munchify(get_album_by_id_response))
actual &lt;span style="color:#ff79c6">=&lt;/span> mock_sp_api&lt;span style="color:#ff79c6">.&lt;/span>get_album_by_id(&lt;span style="color:#f1fa8c">&amp;#39;album_id&amp;#39;&lt;/span>)
mock_sp_api&lt;span style="color:#ff79c6">.&lt;/span>client&lt;span style="color:#ff79c6">.&lt;/span>album&lt;span style="color:#ff79c6">.&lt;/span>assert_called_once_with(&lt;span style="color:#f1fa8c">&amp;#39;album_id&amp;#39;&lt;/span>)
self&lt;span style="color:#ff79c6">.&lt;/span>assertEqual(actual, expected)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Talking about &lt;code>get_mock_sp_api&lt;/code> first, this constructs a new &lt;code>SpApi&lt;/code> wrapper class, but then it overwrites the client attribute with MagicMocks from the unittest framework. MagicMock essentially creates a mocked object or function for you. When I create a MagicMock with a &lt;code>return_value&lt;/code> parameter, it will return that passed parameter when the MagicMock object is invoked.&lt;/p>
&lt;blockquote>
&lt;p>Did you notice how it specifies the return type too?! &lt;code>-&amp;gt; spotify.SpApi&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>The test &lt;code>test_get_album_by_id&lt;/code> creates an instance of this mocked Spotify API, so when we call the wrapper method &lt;code>get_album_by_id&lt;/code> it makes a downstream call to &lt;code>client.album&lt;/code>, which is what we mocked already with the chained MagicMock object! So now we can tell it what to return back when hit with certain parameters - and validating back with &lt;code>assert_called_once_with&lt;/code>.&lt;/p>
&lt;p>Trying to learn how to implement the above has probably been the biggest blocker for me to test Python code in this way - now that I&amp;rsquo;ve discovered it I can&amp;rsquo;t stop using it everywhere!&lt;/p>
&lt;h3 id="complex-object-comparison">Complex Object Comparison&lt;/h3>
&lt;p>Much like the previous section, this relates to the static typing we implemented earlier. I was writing methods that returned complex objects encapsulated in classes, and I wanted to be able to test for equality using unittest&amp;rsquo;s &lt;code>self.assertEqual(actual, expected)&lt;/code>.&lt;/p>
&lt;p>Let&amp;rsquo;s take this simple class:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">SomeObject&lt;/span>():
some_str: &lt;span style="color:#8be9fd;font-style:italic">str&lt;/span>
some_int: &lt;span style="color:#8be9fd;font-style:italic">int&lt;/span>
&lt;span style="color:#ff79c6">def&lt;/span> __init__(self, some_str: &lt;span style="color:#8be9fd;font-style:italic">str&lt;/span>, some_int: &lt;span style="color:#8be9fd;font-style:italic">int&lt;/span>) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> None:
self&lt;span style="color:#ff79c6">.&lt;/span>some_str &lt;span style="color:#ff79c6">=&lt;/span> some_str
self&lt;span style="color:#ff79c6">.&lt;/span>some_int &lt;span style="color:#ff79c6">=&lt;/span> some_int
&lt;/code>&lt;/pre>&lt;/div>&lt;p>What we want to achieve is for us to be able to use the below test like so:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">TestObject&lt;/span>(unittest&lt;span style="color:#ff79c6">.&lt;/span>TestCase):
&lt;span style="color:#ff79c6">def&lt;/span> &lt;span style="color:#50fa7b">test_equality&lt;/span>(self):
&lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;span style="color:#f1fa8c"> Should successfully test for object equality
&lt;/span>&lt;span style="color:#f1fa8c"> Given both objects are equal
&lt;/span>&lt;span style="color:#f1fa8c"> When using self.assertEqual
&lt;/span>&lt;span style="color:#f1fa8c"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
object1 &lt;span style="color:#ff79c6">=&lt;/span> scratch&lt;span style="color:#ff79c6">.&lt;/span>SomeObject(some_str&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;str&amp;#39;&lt;/span>, some_int&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>)
object2 &lt;span style="color:#ff79c6">=&lt;/span> scratch&lt;span style="color:#ff79c6">.&lt;/span>SomeObject(some_str&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;str&amp;#39;&lt;/span>, some_int&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>)
self&lt;span style="color:#ff79c6">.&lt;/span>assertEqual(object1, object2)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>However executing the test gives us an error:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> python test_scratch&lt;span style="color:#ff79c6">.&lt;/span>py
F
&lt;span style="color:#ff79c6">======================================================================&lt;/span>
FAIL: test_equality (__main__&lt;span style="color:#ff79c6">.&lt;/span>TestObject)
&lt;span style="color:#ff79c6">----------------------------------------------------------------------&lt;/span>
Traceback (most recent call last):
File &lt;span style="color:#f1fa8c">&amp;#34;test_scratch.py&amp;#34;&lt;/span>, line &lt;span style="color:#bd93f9">16&lt;/span>, &lt;span style="color:#ff79c6">in&lt;/span> test_equality
self&lt;span style="color:#ff79c6">.&lt;/span>assertEqual(object1, object2)
AssertionError: &lt;span style="color:#ff79c6">&amp;lt;&lt;/span>scratch&lt;span style="color:#ff79c6">.&lt;/span>SomeObject &lt;span style="color:#8be9fd;font-style:italic">object&lt;/span> at &lt;span style="color:#bd93f9">0x000002A0A0199EB8&lt;/span>&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">!=&lt;/span> &lt;span style="color:#ff79c6">&amp;lt;&lt;/span>scratch&lt;span style="color:#ff79c6">.&lt;/span>SomeObject &lt;span style="color:#8be9fd;font-style:italic">object&lt;/span> at &lt;span style="color:#bd93f9">0x000002A0A0199EF0&lt;/span>&lt;span style="color:#ff79c6">&amp;gt;&lt;/span>
&lt;span style="color:#ff79c6">----------------------------------------------------------------------&lt;/span>
Ran &lt;span style="color:#bd93f9">1&lt;/span> test &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#bd93f9">0.003&lt;/span>s
FAILED (failures&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This fails because we have not overwritten the default &lt;code>__eq__&lt;/code> method on the class. Python then defaults to comparing the memory references for both objects. Since these are two entirely different objects they will be pointing to different memory references. What we need to do is tell Python what defines equality, so let&amp;rsquo;s add the method onto &lt;code>SomeObject&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#ff79c6">def&lt;/span> __eq__(self, other):
&lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">type&lt;/span>(other) &lt;span style="color:#ff79c6">!=&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">type&lt;/span>(self):
&lt;span style="color:#ff79c6">return&lt;/span> NotImplemented
&lt;span style="color:#ff79c6">return&lt;/span> self&lt;span style="color:#ff79c6">.&lt;/span>some_str &lt;span style="color:#ff79c6">==&lt;/span> other&lt;span style="color:#ff79c6">.&lt;/span>some_str \
&lt;span style="color:#ff79c6">and&lt;/span> self&lt;span style="color:#ff79c6">.&lt;/span>some_int &lt;span style="color:#ff79c6">==&lt;/span> other&lt;span style="color:#ff79c6">.&lt;/span>some_int
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And here we are! First we are quickly checking to see the two objects are of the same type before we proceed with the underlying values (fail first, and early!). From there we are checking the attributes within the objects. Hurrah!&lt;/p>
&lt;p>One neat little trick I like to do for complex objects that have multiple attributes, is that instead of writing out a new &lt;code>and&lt;/code> comparator for every attribute, is to replace it all with this:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#ff79c6">def&lt;/span> __eq__(self, other):
&lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">type&lt;/span>(other) &lt;span style="color:#ff79c6">!=&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">type&lt;/span>(self):
&lt;span style="color:#ff79c6">return&lt;/span> NotImplemented
&lt;span style="color:#ff79c6">return&lt;/span> self&lt;span style="color:#ff79c6">.&lt;/span>__dict__ &lt;span style="color:#ff79c6">==&lt;/span> other&lt;span style="color:#ff79c6">.&lt;/span>__dict__
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>__dict__&lt;/code> attribute returns the objects in a Python dictionary format, which will contain all the attributes and their values. If the objects are entirely identical then they will return true! Now let&amp;rsquo;s run the test again.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> python test_scratch&lt;span style="color:#ff79c6">.&lt;/span>py
&lt;span style="color:#ff79c6">.&lt;/span>
&lt;span style="color:#ff79c6">----------------------------------------------------------------------&lt;/span>
Ran &lt;span style="color:#bd93f9">1&lt;/span> test &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#bd93f9">0.001&lt;/span>s
OK
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Normal service is resumed!!&lt;/p>
&lt;h2 id="closing">Closing&lt;/h2>
&lt;p>I hope the hints detailed in this helped you as much as it did for me! I&amp;rsquo;m sure there are many more tips out there - as I discover them be sure that I&amp;rsquo;ll share them once I find them, along with documenting more on the side project I&amp;rsquo;ve been working on!&lt;/p>
&lt;p>Thanks for reading ðŸ˜ƒ&lt;/p></description></item></channel></rss>